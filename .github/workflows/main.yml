name: workflow

on:
  push:
    branches:
      - master
    paths-ignore:
      - "README.md"
  workflow_dispatch:

jobs:
  integration:
    name: Continuous integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Lint code
        run: echo "Linting repository"

      - name: Run unit tests
        run: echo "Running unit tests"

  build-and-push-image:
    name: Continuous Delivery
    needs: integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip # jq and unzip are installed, ensure they are needed for other parts of your workflow if not directly used here.

      - name: Azure Container Registry Login
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.CR_LOGIN_SERVER }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          docker build . -t ${{ secrets.CR_LOGIN_SERVER }}/my_app:${{ github.sha }}
          docker push ${{ secrets.CR_LOGIN_SERVER }}/my_app:${{ github.sha }}

  deploy:
    name: Continuous Deployment
    needs: build-and-push-image
    runs-on: self-hosted
    steps:
      - name: Chekcout code
        uses: actions/checkout@v3

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          auth-type: IDENTITY

      - name: Deploy Docker Image to VM
        run: |
          IMAGE_FULL_TAG="${{ secrets.CR_LOGIN_SERVER }}/my_app:${{ github.sha }}"
          TARGET_VM_RESOURCE_GROUP="${{ secrets.VM_RESOURCE_GROUP }}"
          TARGET_VM_NAME="${{ secrets.VM_NAME }}"
          APP_CONTAINER_PORT="${{ secrets.APP_PORT }}"
          APP_CONTAINER_NAME="${{ secrets.CONTAINER_NAME }}"

          echo "Initiating deployment of image $IMAGE_FULL_TAG to VM $TARGET_VM_NAME in resource group $TARGET_VM_RESOURCE_GROUP..."

          az vm run-command invoke \
            --resource-group "$TARGET_VM_RESOURCE_GROUP" \
            --name "$TARGET_VM_NAME" \
            --command-id RunShellScript \
            --scripts \
            "
            echo 'Checking Docker service status on VM...'
            sudo systemctl is-active docker || (echo 'Docker not running, attempting to start...' && sudo systemctl start docker)

            echo 'Logging into Azure Container Registry from VM using Managed Identity...'
            az acr login --name ${{ secrets.CR_LOGIN_SERVER }} --identity

            echo 'Pulling new Docker image: $IMAGE_FULL_TAG...'
            docker pull $IMAGE_FULL_TAG

            echo 'Stopping and removing old container (if existing containers with name $APP_CONTAINER_NAME are found)...'
            # Check for any running or stopped container with the specified name
            if [ \$(docker ps -a -q -f name=$APP_CONTAINER_NAME) ]; then
                docker stop $APP_CONTAINER_NAME || true # Stop, ignoring errors if already stopped
                docker rm $APP_CONTAINER_NAME || true # Remove, ignoring errors if already removed
            fi

            echo 'Starting new container...'
            # Run the new container in detached mode (-d), restart it automatically,
            # assign it the specified name, and map the application port.
            docker run -d --restart always --name $APP_CONTAINER_NAME -p $APP_CONTAINER_PORT:$APP_CONTAINER_PORT $IMAGE_FULL_TAG

            echo 'Deployment on Azure VM complete!'
            # --- End of commands executed on the Azure VM ---
            "
        env:
          CR_LOGIN_SERVER: ${{ secrets.CR_LOGIN_SERVER }}
          VM_RESOURCE_GROUP: ${{ secrets.VM_RESOURCE_GROUP }}
          VM_NAME: ${{ secrets.VM_NAME }}
          APP_PORT: ${{ secrets.APP_PORT }}
          CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
